# bot2.py â€” Twxnâ€™s Prepaid Market (Aiogram v3)
# Fully restored + fixes:
# - Admin panel (Add Cards, Add to Balance, View Users, Remove Stock, Broadcast)
# - Deposit/Wallet address generation (BTC/LTC from XPUB using bip-utils)
# - Shop UI matching screenshot (label + Purchase button per row)
# - Price at 40% + broadcast to stock channel when adding
# - Balance verification via helper service before sending
# - Support tickets + Referrals

import os
import math
import random
import asyncio
from datetime import datetime, timezone
from decimal import Decimal
from typing import Optional, List, Tuple

import aiohttp
from aiogram import Bot, Dispatcher, F, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from cryptography.fernet import Fernet

# ========= ENV =========
BOT_TOKEN = os.getenv("BOT_TOKEN", "")
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///data/market.db")
FERNET_KEY = os.getenv("FERNET_KEY", "")
STOCK_CHANNEL_ID = int(os.getenv("STOCK_CHANNEL_ID", "0"))
SUPPORT_HANDLE = os.getenv("SUPPORT_HANDLE", "@letwxn")
ADMIN_IDS = {int(x) for x in os.getenv("ADMIN_IDS", "8418864166").split(",") if x.strip()}
HELPER_URL = os.getenv("HELPER_URL", "http://twxnhelp:8000")

BTC_XPUB = os.getenv("BTC_XPUB", "").strip()
LTC_XPUB = os.getenv("LTC_XPUB", "").strip()

if not BOT_TOKEN:
    raise SystemExit("âŒ Missing BOT_TOKEN")
if not FERNET_KEY:
    raise SystemExit("âŒ Missing FERNET_KEY")

fernet = Fernet(FERNET_KEY.encode() if isinstance(FERNET_KEY, str) else FERNET_KEY)

# ========= DB / MODELS =========
engine = create_engine(DATABASE_URL, pool_pre_ping=True, future=True)
SessionLocal = sessionmaker(bind=engine, autoflush=False, future=True)

from models import Base, User, Wallet, Card, Order, Referral, ReferralBonus, SupportTicket
Base.metadata.create_all(bind=engine)

# ========= AIROGRAM =========
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# ========= HELPERS =========
def is_admin(uid: int) -> bool:
    return uid in ADMIN_IDS

def enc_text(s: str) -> str:
    return fernet.encrypt(s.encode()).decode()

def dec_text(s: str) -> str:
    return fernet.decrypt(s.encode()).decode()

def money(v) -> str:
    return f"${Decimal(v):.2f}"

def paginate(items: List, page: int, per: int = 10):
    total = len(items)
    pages = max(1, math.ceil(total / per))
    page = max(1, min(page, pages))
    start = (page - 1) * per
    end = start + per
    return items[start:end], page, pages

def get_or_create_wallet(db, user_id: int, coin: str) -> Wallet:
    w = db.query(Wallet).filter(Wallet.user_id == user_id, Wallet.coin == coin).first()
    if w:
        return w
    w = Wallet(user_id=user_id, coin=coin, balance=Decimal("0"))
    db.add(w); db.commit(); db.refresh(w)
    return w

def compute_rate_for_card(card: Card) -> Decimal:
    # listing price at 40% of balance
    return Decimal("0.40")

def now_utc_hhmmss() -> str:
    return datetime.now(timezone.utc).strftime("%H:%M:%S UTC")

# ========= XPUB ADDRESS GEN (BIP84 bech32) =========
def _derive_address_from_xpub(xpub: str, index: int, coin_type: str) -> Optional[str]:
    if not xpub:
        return None
    try:
        from bitcoinlib.wallets import Wallet
        coin = Bip84Coins.BITCOIN if coin_type == "BTC" else Bip84Coins.LITECOIN
        acct = Bip84.FromXPub(xpub, coin)
        return acct.Change(Bip84.Change.EXTERNAL).AddressIndex(index).PublicKey().ToAddress()
    except Exception:
        return None

def _next_index_for_user(db, user_id: int, coin: str) -> int:
    w = db.query(Wallet).filter(Wallet.user_id == user_id, Wallet.coin == coin).first()
    if not w:
        w = Wallet(user_id=user_id, coin=coin, balance=Decimal("0"), address_index=0)
        db.add(w); db.commit(); db.refresh(w)
    if w.address_index is None:
        w.address_index = 0
    return int(w.address_index)

def ensure_deposit_address(db, user_id: int, coin: str) -> Optional[str]:
    w = db.query(Wallet).filter(Wallet.user_id == user_id, Wallet.coin == coin).first()
    if not w:
        w = Wallet(user_id=user_id, coin=coin, balance=Decimal("0"))
        db.add(w); db.commit(); db.refresh(w)

    if w.deposit_address:
        return w.deposit_address

    xpub = BTC_XPUB if coin == "BTC" else LTC_XPUB if coin == "LTC" else ""
    if not xpub:
        return None

    idx = _next_index_for_user(db, user_id, coin)
    addr = _derive_address_from_xpub(xpub, idx, coin)
    if addr:
        w.deposit_address = addr
        w.address_index = idx + 1
        db.commit(); db.refresh(w)
        return addr
    return None

# ========= HELPER SERVICE =========
async def helper_check_balance(number, exp, code):
    try:
        async with aiohttp.ClientSession() as session:
            async with session.post(BALANCE_CHECKER_URL, json={"number": number, "exp": exp, "code": code}) as r:
                if r.status == 200:
                    data = await r.json()
                    return data
                else:
                    return {"status": "error", "balance": 0}
    except Exception as e:
        print("Balance checker error:", e)
        return {"status": "error", "balance": 0}


# ========= HOME =========
def home_message_text(usd_balance: Decimal, purchased: int, stock_count: int) -> str:
    return (
        "ğŸ’³ *Welcome to Twxnâ€™s Prepaid Market!*\n\n"
        "ğŸ’° *Account Info:*\n"
        f"â€¢ Account Balance: *{money(usd_balance)}*\n"
        f"â€¢ Purchased cards: *{purchased}*\n"
        f"â€¢ In stock now: *{stock_count}*\n\n"
        "ğŸ“° *Stock Updates:*\n"
        "Join the channel for live updates.\n\n"
        "ğŸ†˜ *Need Help?*\n"
        f"Open a *Support Ticket* below or reach out at {SUPPORT_HANDLE}"
    )

def home_menu_kb(is_admin_user: bool) -> InlineKeyboardMarkup:
    pool = [
        InlineKeyboardButton(text="ğŸ§¾ View Listings", callback_data="shop:page:1"),
        InlineKeyboardButton(text="ğŸ’µ Deposit", callback_data="home:wallet"),
        InlineKeyboardButton(text="ğŸ›’ Purchase History", callback_data="home:orders"),
        InlineKeyboardButton(text="ğŸ Referrals", callback_data="home:referral"),
        InlineKeyboardButton(text="ğŸ†˜ Support Ticket", callback_data="home:support"),
    ]
    random.shuffle(pool)
    rows = []
    if pool:
        rows.append([pool[0]])  # first row single
        for i in range(1, len(pool), 2):
            rows.append(pool[i:i+2])
    if is_admin_user:
        rows.append([InlineKeyboardButton(text="âš™ï¸ Admin Panel", callback_data="admin:menu")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

@dp.message(Command("start"))
async def on_start(msg: types.Message):
    db = SessionLocal()
    try:
        u = db.get(User, msg.from_user.id)
        if not u:
            u = User(id=msg.from_user.id, username=msg.from_user.username, display_name=msg.from_user.full_name)
            db.add(u); db.commit()
        # referrals: /start ref_<id>
        try:
            if msg.text and " " in msg.text:
                _, param = msg.text.split(" ", 1)
                param = param.strip()
                if param.startswith("ref_"):
                    ref_id = int(param.replace("ref_", ""))
                    if ref_id != msg.from_user.id:
                        ex = db.query(Referral).filter(Referral.user_id == msg.from_user.id).first()
                        if not ex:
                            db.add(Referral(user_id=msg.from_user.id, referrer_id=ref_id)); db.commit()
        except Exception:
            pass

        w_usd = get_or_create_wallet(db, msg.from_user.id, "USD")
        purchased = db.query(Order).filter(Order.user_id == msg.from_user.id).count()
        stock = db.query(Card).filter(Card.status == "in_stock").count()
        await msg.answer(
            home_message_text(Decimal(w_usd.balance or 0), purchased, stock),
            parse_mode="Markdown",
            reply_markup=home_menu_kb(is_admin(msg.from_user.id))
        )
    finally:
        db.close()

@dp.callback_query(F.data == "home:back")
async def home_back(cq: types.CallbackQuery):
    db = SessionLocal()
    try:
        w_usd = get_or_create_wallet(db, cq.from_user.id, "USD")
        purchased = db.query(Order).filter(Order.user_id == cq.from_user.id).count()
        stock = db.query(Card).filter(Card.status == "in_stock").count()
        await cq.message.edit_text(
            home_message_text(Decimal(w_usd.balance or 0), purchased, stock),
            parse_mode="Markdown",
            reply_markup=home_menu_kb(is_admin(cq.from_user.id))
        )
    finally:
        db.close()

# ========= WALLET / DEPOSIT =========
@dp.callback_query(F.data == "home:wallet")
async def wallet_inline(cq: types.CallbackQuery):
    await cq.answer()
    db = SessionLocal()
    try:
        w_usd = get_or_create_wallet(db, cq.from_user.id, "USD")
        w_btc = get_or_create_wallet(db, cq.from_user.id, "BTC")
        w_ltc = get_or_create_wallet(db, cq.from_user.id, "LTC")
        usd = Decimal(w_usd.balance or 0)
        btc = Decimal(w_btc.balance or 0)
        ltc = Decimal(w_ltc.balance or 0)
    finally:
        db.close()

    txt = (
        "ğŸ¦ *Make a Deposit*\n\n"
        f"USD: {money(usd)}\n"
        f"BTC: {btc:.8f} (~{money(Decimal('0'))})\n"
        f"LTC: {ltc:.8f} (~{money(Decimal('0'))})\n\n"
        "Choose a coin below. Your USD wallet is credited after *2 confirmations*."
    )
    kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="ğŸ”¸ Deposit BTC", callback_data="deposit:BTC"),
         InlineKeyboardButton(text="ğŸ”¹ Deposit LTC", callback_data="deposit:LTC")],
        [InlineKeyboardButton(text="â¬…ï¸ Back to Home", callback_data="home:back")]
    ])
    await cq.message.edit_text(txt, parse_mode="Markdown", reply_markup=kb)

@dp.callback_query(lambda c: c.data and c.data.startswith("deposit:"))
async def deposit_addr(cq: types.CallbackQuery):
    await cq.answer()
    coin = cq.data.split(":")[1]
    db = SessionLocal()
    try:
        addr = ensure_deposit_address(db, cq.from_user.id, coin)
    finally:
        db.close()
    if not addr:
        await cq.message.answer(
            f"âš ï¸ Could not generate a {coin} address (missing/invalid XPUB or derivation library).",
            reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="home:wallet")]])
        )
        return
    await cq.message.answer(
        f"ğŸ“¥ Send *{coin}* to:\n`{addr}`\n\nWe credit your *USD* wallet after 2 confirmations.",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="home:wallet")]])
    )

# ========= SHOP =========
def listings_header(db, uid: int) -> str:
    w_usd = get_or_create_wallet(db, uid, "USD")
    w_btc = get_or_create_wallet(db, uid, "BTC")
    w_ltc = get_or_create_wallet(db, uid, "LTC")
    header = (
        "ğŸ’ *Twxn's Main Listings* ğŸ’\n\n"
        "Your Balance:\n"
        f"ğŸª™ USD: *{money(Decimal(w_usd.balance or 0))}*\n"
        f"â€¢ BTC: {Decimal(w_btc.balance or 0):.8f} ({money(0)})\n"
        f"â€¢ LTC: {Decimal(w_ltc.balance or 0):.8f} ({money(0)})\n\n"
    )
    return header

def shop_row_kb(card: Card) -> List[List[InlineKeyboardButton]]:
    label = f"{card.bin} ${Decimal(card.balance):.2f}"
    return [[
        InlineKeyboardButton(text=f"{label[:12]}â€¦${Decimal(card.balance):.2f}" if len(label) > 12 else label, callback_data="noop"),
        InlineKeyboardButton(text="ğŸ›’ Purchase", callback_data=f"shop:buy:{card.id}")
    ]]

@dp.callback_query(F.data.startswith("shop:page:"))
async def shop_page(cq: types.CallbackQuery):
    _, _, page_s = cq.data.split(":")
    page = int(page_s)
    db = SessionLocal()
    try:
        cards = db.query(Card).filter(Card.status == "in_stock").order_by(Card.id.asc()).all()
        subset, page, pages = paginate(cards, page, 20)
        text = listings_header(db, cq.from_user.id)

        # top list as text like screenshot
        lines = []
        for i, c in enumerate(subset, 1):
            lines.append(f"{i}. {c.bin} USD{Decimal(c.balance):.2f} at 40% |")
        text += "\n".join(lines) + f"\n\nPage {page}/{pages} | Updated: {now_utc_hhmmss()}"

        rows = []
        for c in subset:
            rows.extend(shop_row_kb(c))

        nav = []
        if page > 1:
            nav.append(InlineKeyboardButton(text="â¬… Prev", callback_data=f"shop:page:{page-1}"))
        if page < pages:
            nav.append(InlineKeyboardButton(text="Next â¡", callback_data=f"shop:page:{page+1}"))
        if nav:
            rows.append(nav)
        rows.append([InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="home:back")])

        await cq.message.edit_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(inline_keyboard=rows))
    finally:
        db.close()

@dp.callback_query(F.data.startswith("shop:buy:"))
async def shop_buy_request(cq: types.CallbackQuery):
    _, _, cid_s = cq.data.split(":")
    cid = int(cid_s)
    db = SessionLocal()
    try:
        card = db.get(Card, cid)
        if not card or card.status != "in_stock":
            await cq.message.answer("ğŸš« Card not available.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="shop:page:1")]]))
            return
        rate = compute_rate_for_card(card)
        sale_price = (Decimal(card.price or 0) or (Decimal(card.balance or 0) * rate)).quantize(Decimal("0.01"))
        kb = InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=f"âœ… Confirm {money(sale_price)}", callback_data=f"shop:confirm:{cid}:{sale_price}")],
            [InlineKeyboardButton(text="âŒ Cancel", callback_data="shop:page:1")]
        ])
        await cq.message.answer(
            f"âš ï¸ Confirm purchase of *{card.bin}* id:{cid} for *{money(sale_price)}* ?",
            parse_mode="Markdown",
            reply_markup=kb
        )
    finally:
        db.close()

@dp.callback_query(F.data.startswith("shop:confirm:"))
async def shop_buy_confirm(cq: types.CallbackQuery):
    _, _, cid_s, price_s = cq.data.split(":")
    cid = int(cid_s); sale_price = Decimal(price_s)
    db = SessionLocal()
    try:
        card = db.get(Card, cid)
        if not card or card.status != "in_stock":
            await cq.message.answer("ğŸš« Card not available.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="shop:page:1")]]))
            return

        w_usd = get_or_create_wallet(db, cq.from_user.id, "USD")
        if Decimal(w_usd.balance or 0) < sale_price:
            await cq.message.answer(f"âŒ Not enough USD balance. Need {money(sale_price)}.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="shop:page:1")]]))
            return

        # Live check
        number = card.cc_number or ""
        exp = (card.exp or "").replace(" ", "")
        try:
            code = dec_text(card.encrypted_code)
        except Exception:
            code = ""
        chk = await helper_check_balance(number, exp, code)
        status = chk.get("status")
        new_bal = Decimal(str(chk.get("balance", "0")))

        if status not in ("ok",) or new_bal <= 0:
            await cq.message.answer("âŒ Card failed verification. Purchase canceled.", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="shop:page:1")]]))
            return

        # If balance changed â€” update & ask to reconfirm
        if new_bal != Decimal(card.balance or 0):
            card.balance = new_bal
            db.commit()
            await cq.message.answer(
                f"â„¹ï¸ Balance changed to {money(new_bal)}. Listing updated. Please purchase again.",
                reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="ğŸ§¾ View Listings", callback_data="shop:page:1")]])
            )
            return

        # Proceed: deduct and deliver
        w_usd.balance = Decimal(w_usd.balance or 0) - sale_price
        card.status = "sold"
        order = Order(user_id=cq.from_user.id, card_id=card.id, price_usd=sale_price, coin_used="USD", coin_amount=sale_price, status="completed")
        db.add(order); db.commit(); db.refresh(order)

        revealed = ""
        try:
            revealed = dec_text(card.encrypted_code)
        except Exception:
            revealed = "(encrypted)"
        msg = (
            f"âœ… Purchase complete!\n\n"
            f"Card id: {card.id}\n"
            f"Site: {card.site or 'â€”'}\n"
            f"BIN: {card.bin}\n"
            f"CC: {card.cc_number}\n"
            f"EXP: {card.exp}\n"
            f"CODE: `{revealed}`\n\n"
            f"Paid: {money(sale_price)}\nOrder ID: {order.id}"
        )
        await cq.message.answer(msg, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back to Home", callback_data="home:back")]]))
    finally:
        db.close()

# ========= SUPPORT =========
class SupportSG(StatesGroup):
    waiting_subject = State()

@dp.callback_query(F.data == "home:support")
async def support_start(cq: types.CallbackQuery, state: FSMContext):
    await cq.answer()
    await state.set_state(SupportSG.waiting_subject)
    await cq.message.answer("ğŸ†˜ Send a brief subject for your support ticket:")

@dp.message(SupportSG.waiting_subject)
async def support_subject(msg: types.Message, state: FSMContext):
    db = SessionLocal()
    try:
        t = SupportTicket(user_id=msg.from_user.id, subject=msg.text.strip(), status="open")
        db.add(t); db.commit(); db.refresh(t)
        # notify admins (first admin id)
        for admin_id in ADMIN_IDS:
            try:
                await bot.send_message(admin_id, f"ğŸ« New Support Ticket #{t.id} from @{msg.from_user.username or msg.from_user.id}\n\n{t.subject}")
            except Exception:
                pass
        await msg.answer(f"âœ… Ticket #{t.id} created. Weâ€™ll reply soon.")
    finally:
        db.close()
    await state.clear()

# ========= REFERRALS =========
@dp.callback_query(F.data == "home:referral")
async def referral_info(cq: types.CallbackQuery):
    invite = f"https://t.me/{(await bot.get_me()).username}?start=ref_{cq.from_user.id}"
    db = SessionLocal()
    try:
        cnt = db.query(Referral).filter(Referral.referrer_id == cq.from_user.id).count()
    finally:
        db.close()
    await cq.message.answer(
        f"ğŸ *Referral Program*\n\nShare this link:\n{invite}\n\nReferrals so far: *{cnt}*",
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="home:back")]])
    )

# ========= ADMIN =========
class AddCardSG(StatesGroup):
    waiting_line = State()

class AddBalanceSG(StatesGroup):
    waiting_user = State()
    waiting_amount = State()

class RemoveStockSG(StatesGroup):
    waiting_id = State()

def admin_menu_kb():
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="â• Add Cards", callback_data="admin:add")],
        [InlineKeyboardButton(text="ğŸ’³ Add to User Balance", callback_data="admin:add_balance")],
        [InlineKeyboardButton(text="ğŸ‘¥ View All Users", callback_data="admin:view_users:1")],
        [InlineKeyboardButton(text="ğŸ—‘ Remove Stock", callback_data="admin:remove_stock")],
        [InlineKeyboardButton(text="ğŸ“¢ Broadcast Stock Count", callback_data="admin:broadcast")],
        [InlineKeyboardButton(text="ğŸ—‚ View Sales (soon)", callback_data="admin:view_sales")],
        [InlineKeyboardButton(text="ğŸ« Support Tickets (soon)", callback_data="admin:support")],
        [InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="home:back")]
    ])

@dp.callback_query(F.data == "admin:menu")
async def admin_menu(cq: types.CallbackQuery):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await cq.message.edit_text("ğŸ‘‘ Admin Panel", reply_markup=admin_menu_kb())

# Add cards
@dp.callback_query(F.data == "admin:add")
async def admin_add_cards_start(cq: types.CallbackQuery, state: FSMContext):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await state.set_state(AddCardSG.waiting_line)
    await cq.message.edit_text(
        "â• *Add Cards*\n\nSend one line per card:\n`SITE|BIN|CC_NUMBER|EXP|PIN/CODE|BALANCE`",
        parse_mode="Markdown"
    )

@dp.message(AddCardSG.waiting_line)
async def admin_add_cards_receive(msg: types.Message, state: FSMContext):
    if not is_admin(msg.from_user.id):
        return
    line = msg.text.strip()
    try:
        parts = [p.strip() for p in line.split("|")]
        if len(parts) != 6:
            raise ValueError("Need 6 fields")
        site, bin6, cc, exp, code, bal_s = parts
        bal = Decimal(bal_s)

        db = SessionLocal()
        try:
            c = Card(
                site=site, bin=bin6, cc_number=cc, exp=exp,
                encrypted_code=enc_text(code),
                balance=bal, currency="USD", status="in_stock",
                added_by=msg.from_user.id
            )
            db.add(c); db.commit(); db.refresh(c)

            # broadcast
            try:
                if STOCK_CHANNEL_ID:
                    await bot.send_message(STOCK_CHANNEL_ID, f"ğŸ†• New card: {site} {bin6} â€¢ {money(bal)} â€¢ id {c.id} (40%)")
            except Exception:
                pass

            await msg.answer(f"âœ… Card #{c.id} added.")
        finally:
            db.close()
        await state.clear()
    except Exception as e:
        await msg.answer(f"âŒ Failed: {e}\nFormat: `SITE|BIN|CC|EXP|PIN/CODE|BALANCE`", parse_mode="Markdown")

# Add to user balance
@dp.callback_query(F.data == "admin:add_balance")
async def admin_add_balance_start(cq: types.CallbackQuery, state: FSMContext):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await state.set_state(AddBalanceSG.waiting_user)
    await cq.message.edit_text("ğŸ’³ Send the *User ID* to credit:", parse_mode="Markdown")

@dp.message(AddBalanceSG.waiting_user)
async def admin_add_balance_user(msg: types.Message, state: FSMContext):
    try:
        uid = int(msg.text.strip())
        await state.update_data(uid=uid)
        await state.set_state(AddBalanceSG.waiting_amount)
        await msg.answer("Amount in USD (e.g. 25.00):")
    except Exception:
        await msg.answer("Send a numeric User ID.")

@dp.message(AddBalanceSG.waiting_amount)
async def admin_add_balance_amount(msg: types.Message, state: FSMContext):
    data = await state.get_data()
    uid = int(data.get("uid"))
    try:
        amt = Decimal(msg.text.strip()).quantize(Decimal("0.01"))
        db = SessionLocal()
        try:
            w = get_or_create_wallet(db, uid, "USD")
            w.balance = Decimal(w.balance or 0) + amt
            db.commit()
        finally:
            db.close()
        await msg.answer(f"âœ… Credited {money(amt)} to user {uid}.")
        await state.clear()
    except Exception as e:
        await msg.answer(f"Error: {e}")

# View users
def users_page_kb(users, page, pages):
    rows = []
    for u in users:
        rows.append([InlineKeyboardButton(text=f"{u.id} @{u.username or ''}", callback_data="noop")])
    nav = []
    if page > 1:
        nav.append(InlineKeyboardButton(text="â¬… Prev", callback_data=f"admin:view_users:{page-1}"))
    if page < pages:
        nav.append(InlineKeyboardButton(text="Next â¡", callback_data=f"admin:view_users:{page+1}"))
    if nav:
        rows.append(nav)
    rows.append([InlineKeyboardButton(text="â¬…ï¸ Back", callback_data="admin:menu")])
    return InlineKeyboardMarkup(inline_keyboard=rows)

@dp.callback_query(F.data.startswith("admin:view_users:"))
async def admin_view_users(cq: types.CallbackQuery):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    _, _, page_s = cq.data.split(":")
    page = int(page_s)
    db = SessionLocal()
    try:
        users = db.query(User).order_by(User.id.asc()).all()
        subset, page, pages = paginate(users, page, 15)

        lines = []
        for u in subset:
            w = get_or_create_wallet(db, u.id, "USD")
            lines.append(f"{u.id} @{u.username or ''} â€” USD {money(Decimal(w.balance or 0))}")
        text = "ğŸ‘¥ *All Users*\n\n" + "\n".join(lines) + f"\n\nPage {page}/{pages}"
        await cq.message.edit_text(text, parse_mode="Markdown", reply_markup=users_page_kb(subset, page, pages))
    finally:
        db.close()

# Remove stock
@dp.callback_query(F.data == "admin:remove_stock")
async def admin_remove_stock_start(cq: types.CallbackQuery, state: FSMContext):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await state.set_state(RemoveStockSG.waiting_id)
    await cq.message.edit_text("ğŸ—‘ Send the Card ID to remove from stock:")

@dp.message(RemoveStockSG.waiting_id)
async def admin_remove_stock_do(msg: types.Message, state: FSMContext):
    try:
        cid = int(msg.text.strip())
        db = SessionLocal()
        try:
            card = db.get(Card, cid)
            if not card:
                await msg.answer("No such card id.")
            else:
                card.status = "sold"
                db.commit()
                await msg.answer(f"âœ… Card {cid} removed from stock.")
        finally:
            db.close()
        await state.clear()
    except Exception:
        await msg.answer("Send a numeric Card ID.")

# Broadcast
@dp.callback_query(F.data == "admin:broadcast")
async def admin_broadcast_stock(cq: types.CallbackQuery):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    db = SessionLocal()
    try:
        cnt = db.query(Card).filter(Card.status == "in_stock").count()
    finally:
        db.close()
    if not STOCK_CHANNEL_ID:
        return await cq.answer("STOCK_CHANNEL_ID not set.", show_alert=True)
    await bot.send_message(STOCK_CHANNEL_ID, f"ğŸ“¦ Stock live: {cnt} card(s).")
    await cq.answer("Sent.")

@dp.callback_query(F.data == "admin:view_sales")
async def admin_view_sales(cq: types.CallbackQuery):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await cq.answer("Coming soon.")

@dp.callback_query(F.data == "admin:support")
async def admin_support(cq: types.CallbackQuery):
    if not is_admin(cq.from_user.id):
        return await cq.answer("Not allowed.", show_alert=True)
    await cq.answer("Coming soon.")

# ======== NOOP catcher (for left labels) ========
@dp.callback_query(F.data == "noop")
async def noop_cb(cq: types.CallbackQuery):
    await cq.answer()

# ========= RUN =========
async def main():
    me = await bot.get_me()
    print(f"ğŸ¤– Running as: @{me.username}")
    await dp.start_polling(bot)

if __name__ == "__main__":
    asyncio.run(main())

